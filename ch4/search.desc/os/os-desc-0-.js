searchState.loadedDescShard("os", 0, "The main module and entrypoint\nclear BSS segment\nConstants in the kernel\nSBI console driver, for text output\nkernel log info\nThe panic handler\nLoading user applications into memory\nGlobal logger\nMemory management implementation\nPrint! to the host console using the format string and …\nPrintln! to the host console using the format string and …\nthe rust entry-point of os\nSBI call wrappers\nSynchronization and interior mutability primitives\nImplementation of syscalls\nTask management implementation\nRISC-V timer-related functionality\nTrap handling functionality\nclock frequency\nkernel heap size\nkernel stack size\nthe max number of syscall\nthe physical memory end\npage size : 4KB\npage size bits: 12\nthe virtual addr of trapoline\nthe virtual addr of trap context\nuser app’s stack size\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\npanic handler\nget applications data\nGet the total number of applications.\na simple logger\nReturns the argument unchanged.\ninitiate logger\nCalls <code>U::from(self)</code>.\ntracker for physical page frame allocation and deallocation\nThe kernel’s initial memory mapping(kernel address space)\nmap permission corresponding to that in pte: <code>R W X U</code>\naddress space\npage table entry flags\npage table structure\npage table entry structure\nphysical address\nphysical page number\nvirtual address\nvirtual page number\nImplementation of physical and virtual address and page …\nbits of page table entry\nAllocate a physical page frame in FrameTracker style\nImplementation of <code>FrameAllocator</code> which controls all the …\nThe global allocator\ninitiate heap allocator, frame allocator and kernel space\nReturn (bottom, top) of a kernel stack in kernel space.\nImplementation of <code>MapArea</code> and <code>MemorySet</code>.\nImplementation of <code>PageTableEntry</code> and <code>PageTable</code>.\nphysical page number\nremap test in kernel space\nTranslate&amp;Copy a ptru8 array with LENGTH len to a mutable …\nphysical address\nphysical address\nphysical page number\na simple range structure for type T\niterator for the simple range structure\niterator for phy/virt page number\na simple range structure for virtual page number\nvirtual address\nvirtual page number\nCheck if the physical address is aligned by page size\nCheck if the virtual address is aligned by page size\nGet the (ceil) physical page number\nGet the (ceil) virtual page number\nGet the (floor) physical page number\nGet the (floor) virtual page number\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the reference of page(array of bytes)\nGet mutable reference to <code>PhysAddr</code> value Get the mutable …\nGet the mutable reference of physical address\nGet the reference of page table(array of ptes)\nGet the indexes of the page table entry\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the page offset of physical address\nGet the page offset of virtual address\nstep by one element(page number)\nframe allocator instance through lazy_static!\ntracker for physical page frame allocation and deallocation\nan implementation for frame allocator\nAllocate a physical page frame in FrameTracker style\na simple test for frame allocator\nDeallocate a physical page frame with a given ppn\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\ninitiate the frame allocator using <code>ekernel</code> and <code>MEMORY_END</code>\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new FrameTracker\nphysical page number\nheap allocator instance\nheap space ([u8; KERNEL_HEAP_SIZE])\npanic when heap allocation error occurs\ninitiate heap allocator\nThe kernel’s initial memory mapping(kernel address space)\nmap area structure, controls a contiguous piece of virtual …\nmap permission corresponding to that in pte: <code>R W X U</code>\nmap type for memory set: identical or framed\naddress space\nReadable\nAccessible in U mode\nWritable\nExcutable\nChange page table by writing satp CSR Register.\nReturns the set containing all flags.\nappend the area to new_end\nReturns the intersection between the two sets of flags.\nDisables all flags disabled in the set.\nReturns the union of the two sets of flags.\nAdds the set of flags.\nReturns the raw value of the flags currently stored.\nReturns the left flags, but with all the right flags …\nToggles the set of flags.\nReturns the complement of this set of flags.\nReturns <code>true</code> if all of the flags in <code>other</code> are contained …\ndata: start-aligned but maybe with shorter length assume …\nReturns the difference between the flags in <code>self</code> and <code>other</code>.\nReturns an empty set of flags.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from underlying bit representation, unless that …\nConvert from underlying bit representation, dropping any …\nConvert from underlying bit representation, preserving all …\nInclude sections in elf and trampoline and TrapContext and …\nInserts the specified flags in-place.\nAssume that no conflicts.\nReturns the intersection between the flags in <code>self</code> and …\nReturns <code>true</code> if there are flags common to both <code>self</code> and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if all flags are currently set.\nReturns <code>true</code> if no flags are currently stored.\nReturn (bottom, top) of a kernel stack in kernel space.\nMention that trampoline is not collected by areas.\nCreate a new empty <code>MemorySet</code>.\nWithout kernel stacks.\nReturns the complement of this set of flags.\nremap test in kernel space\nRemoves the specified flags in-place.\nInserts or removes the specified flags depending on the …\nshrink the area to new_end\nReturns the set difference of the two sets of flags.\nDisables all flags enabled in the set.\nReturns the symmetric difference between the flags in <code>self</code> …\nToggles the specified flags in-place.\nGet the page table token\nTranslate a virtual page number to a page table entry\nReturns the union of between the flags in <code>self</code> and <code>other</code>.\nAccessed\nDirty\nGlobal\npage table entry flags\npage table structure\npage table entry structure\nReadable\nUser\nValid\nWritable\neXecutable\nReturns the set containing all flags.\nReturns the intersection between the two sets of flags.\nDisables all flags disabled in the set.\nReturns the union of the two sets of flags.\nAdds the set of flags.\nReturns the raw value of the flags currently stored.\nbits of page table entry\nReturns the left flags, but with all the right flags …\nToggles the set of flags.\nReturns the complement of this set of flags.\nReturns <code>true</code> if all of the flags in <code>other</code> are contained …\nReturns the difference between the flags in <code>self</code> and <code>other</code>.\nReturns an empty set of flags.\nCreate an empty page table entry\nThe page pointered by page table entry is executable?\nFind PageTableEntry by VirtPageNum\nFind PageTableEntry by VirtPageNum, create a frame for a …\nGet the flags from the page table entry\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from underlying bit representation, unless that …\nConvert from underlying bit representation, dropping any …\nConvert from underlying bit representation, preserving all …\nTemporarily used to get arguments from user space.\nInserts the specified flags in-place.\nReturns the intersection between the flags in <code>self</code> and …\nReturns <code>true</code> if there are flags common to both <code>self</code> and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if all flags are currently set.\nReturns <code>true</code> if no flags are currently stored.\nThe page pointered by page table entry is valid?\nset the map between virtual page number and physical page …\nCreate a new page table\nCreate a new page table entry\nReturns the complement of this set of flags.\nGet the physical page number from the page table entry\nThe page pointered by page table entry is readable?\nRemoves the specified flags in-place.\nInserts or removes the specified flags depending on the …\nReturns the set difference of the two sets of flags.\nDisables all flags enabled in the set.\nReturns the symmetric difference between the flags in <code>self</code> …\nToggles the specified flags in-place.\nget the token from the page table\nget the page table entry from the virtual page number\nTranslate&amp;Copy a ptru8 array with LENGTH len to a mutable …\nReturns the union of between the flags in <code>self</code> and <code>other</code>.\nremove the map between virtual page number and physical …\nThe page pointered by page table entry is writable?\nuse sbi call to putchar in console (qemu uart handler)\ngeneral sbi call\nuse sbi call to set timer\nuse sbi call to shutdown the kernel\nWrap a static data structure inside it so that we are able …\ninner data\nUniprocessor interior mutability primitives\nWrap a static data structure inside it so that we are able …\nPanic if the data has been borrowed.\nReturns the argument unchanged.\ninner data\nCalls <code>U::from(self)</code>.\nUser is responsible to guarantee that inner struct is only …\nexit syscall\ngettime syscall\nmmap syscall\nmunmap syscall\nsbrk syscall\ntrace syscall\nyield syscall\nFile and filesystem-related syscalls\nProcess management syscalls\nhandle syscall exception with <code>syscall_id</code> and other …\nwrite buf of length <code>len</code>  to a file with <code>fd</code>\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\ntask exits and submit an exit code\nYOUR JOB: get time with second and microsecond HINT: You …\nchange data segment size\nTODO: Finish sys_trace to pass testcases HINT: You might …\ncurrent task gives up resources for other tasks\nexited\nready to run\nrunning\na <code>TaskManager</code> global instance through lazy_static!\ntask context structure containing some registers\nThe task control block (TCB) of a task.\nThe task manager, where all the tasks are managed.\nThe task manager inner in ‘UPSafeCell’\ntask status: UnInit, Ready, Running, Exited\nuninitialized\nThe size(top addr) of program which is loaded from elf file\nChange the current ‘Running’ task’s program break\nChange the current ‘Running’ task’s program break\nImplementation of <code>TaskContext</code>\nid of current <code>Running</code> task\nGet the current ‘Running’ task’s trap contexts.\nGet the current ‘Running’ task’s token.\nExit the current ‘Running’ task and run the next task …\nFind next task to run and return task id.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the current ‘Running’ task’s token.\nGet the current ‘Running’ task’s trap contexts.\nHeap bottom\nuse inner value to get mutable access\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChange the status of current <code>Running</code> task into <code>Exited</code>.\nChange the status of current <code>Running</code> task into <code>Exited</code>.\nChange the status of current <code>Running</code> task into <code>Ready</code>.\nChange the status of current <code>Running</code> task into <code>Ready</code>.\nApplication address space\ntotal number of tasks\nProgram break\nRet position after task switching\nRun the first task in task list.\nRun the first task in task list.\nSwitch current <code>Running</code> task to the task we have found, or …\nSwitch current <code>Running</code> task to the task we have found, or …\ns0-11 register, callee saved\nStack pointer\nSuspend the current ‘Running’ task and run the next …\nRust wrapper around <code>__switch</code>.\nTypes related to task management\nSave task context\nMaintain the execution status of the current process\ntask list\nThe phys page number of trap context\ntask context structure containing some registers\nReturns the argument unchanged.\nCreate a new task context with a trap return addr and a …\nCalls <code>U::from(self)</code>.\nRet position after task switching\ns0-11 register, callee saved\nStack pointer\nCreate a new empty task context\nSwitch to the context of <code>next_task_cx_ptr</code>, saving the …\nexited\nready to run\nrunning\nThe task control block (TCB) of a task.\ntask status: UnInit, Ready, Running, Exited\nuninitialized\nThe size(top addr) of program which is loaded from elf file\nchange the location of the program break. return None if …\nReturns the argument unchanged.\nReturns the argument unchanged.\nget the trap context\nget the user token\nHeap bottom\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nApplication address space\nBased on the elf info in program, build the contents of …\nProgram break\nSave task context\nMaintain the execution status of the current process\nThe phys page number of trap context\nThe number of microseconds per second\nThe number of milliseconds per second\nThe number of ticks per second\nGet the current time in ticks\nget current time in milliseconds\nget current time in microseconds\nSet the next timer interrupt\ntrap context structure containing sstatus, sepc and …\nImplementation of <code>TrapContext</code>\nenable timer interrupt in supervisor mode\nInitialize trap handling\nToken of kernel address space\nKernel stack pointer of the current application\nSupervisor Exception Program Counter\nSupervisor Status Register\nhandle trap from kernel Unimplement: …\ntrap handler\nVirtual address of trap handler entry point in kernel\nreturn to user space set the new addr of __restore asm …\nGeneral-Purpose Register x0-31\ntrap context structure containing sstatus, sepc and …\ninit the trap context of an application\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nToken of kernel address space\nKernel stack pointer of the current application\nSupervisor Exception Program Counter\nput the sp(stack pointer) into x[2] field of TrapContext\nSupervisor Status Register\nVirtual address of trap handler entry point in kernel\nGeneral-Purpose Register x0-31")